/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void SystemClock_Config(void);
void InitMCOGPIO(void);
void Init_GPIO_PWM(void);
void Start_TIM_PWM(void);

#define FLASH_BASE_ADDRESS						(0x40023C00UL)
#define RCC_BASE_ADDRESS 						(0x40023800UL)
#define PWR_BASE_ADDRESS						(0x40007000UL)
#define GPIOA_BASE_ADDRESS						(0x40020000UL)
#define TIM2_BASE_ADDRESS						(0x40000000UL)

#define FLASH_ACCESS_CONTROL_OFFSET				(0x00UL)

#define RCC_CLOCK_CONTROL_OFFSET				(0x00UL)
#define RCC_PLL_CLOCK_CONFIG_OFFSET				(0x04UL)
#define RCC_CLOCK_CONFIG_OFFSET					(0x08UL)
#define RCC_AHB1_CE_OFFSET 						(0x30UL)
#define RCC_APB1_CE_OFFSET 						(0x40UL)

#define PWR_CR_OFFSET							(0x00UL)
#define PWR_CSR_OFFSET							(0x04UL)

#define GPIO_Port_Mode_Offset					(0x00UL)
#define GPIO_Output_Type_Offset					(0x04UL) // Type
#define GPIO_Output_Speed_Offset				(0x08UL) // Speed
#define GPIO_PUPD_Offset						(0x0CUL) // Pull Up / Pull Down
#define GPIO_BSR_Offset							(0x18UL) // Bit Set / Reset
#define GPIO_AF_LOW_Offset						(0x20UL)
#define GPIO_AF_HIGH_Offset						(0x24UL)

#define TIM_CONTROL_OFFSET						(0x00UL)
#define TIM_EGR_OFFSET							(0x14UL)
#define TIM_CCMR1_OFFSET						(0x18UL)
#define TIM_CCE_OFFSET							(0x20UL)
#define TIM_PRS_OFFSET							(0x28UL)
#define TIM_ARR_OFFSET							(0x2CUL)
#define TIM_CCR1_OFFSET							(0x34UL)

#define FLASH_ACCESS_CONTROL_ADDRESS			(FLASH_BASE_ADDRESS + FLASH_ACCESS_CONTROL_OFFSET)

#define PWR_CR_ADDRESS							(PWR_BASE_ADDRESS + PWR_CR_OFFSET)

#define RCC_CLOCK_CONTROL_ADDRESS				(RCC_BASE_ADDRESS + RCC_CLOCK_CONTROL_OFFSET)
#define RCC_PLL_ADDRESS							(RCC_BASE_ADDRESS + RCC_PLL_CLOCK_CONFIG_OFFSET)
#define RCC_CLOCK_CONFIG_ADDRESS				(RCC_BASE_ADDRESS + RCC_CLOCK_CONFIG_OFFSET)
#define RCC_AHB1_CE_ADDRESS						(RCC_BASE_ADDRESS + RCC_AHB1_CE_OFFSET)
#define RCC_APB1_CE_ADDRESS 					(RCC_BASE_ADDRESS + RCC_APB1_CE_OFFSET)

#define GPIOA_Port_Mode_ADDRESS 				(GPIOA_BASE_ADDRESS + GPIO_Port_Mode_Offset)
#define GPIOA_Output_Type_ADDRESS 				(GPIOA_BASE_ADDRESS + GPIO_Output_Type_Offset)
#define GPIOA_Output_Speed_ADDRESS 				(GPIOA_BASE_ADDRESS + GPIO_Output_Speed_Offset)
#define GPIOA_PUPD_ADDRESS 						(GPIOA_BASE_ADDRESS + GPIO_PUPD_Offset)
#define GPIOA_BSR_ADDRESS 						(GPIOA_BASE_ADDRESS + GPIO_BSR_Offset)
#define GPIOA_AF_LOW_ADDRESS					(GPIOA_BASE_ADDRESS + GPIO_AF_LOW_Offset)
#define GPIOA_AF_HIGH_ADDRESS					(GPIOA_BASE_ADDRESS + GPIO_AF_HIGH_Offset)

#define TIM2_CONTROL_ADDRESS					(TIM2_BASE_ADDRESS + TIM_CONTROL_OFFSET)
#define TIM2_EGR_ADDRESS						(TIM2_BASE_ADDRESS + TIM_EGR_OFFSET)
#define TIM2_COMPARE_CAPTURE_MODE_1_ADDRESS		(TIM2_BASE_ADDRESS + TIM_CCMR1_OFFSET)
#define TIM2_CAP_COMP_ENABLE_ADDRESS			(TIM2_BASE_ADDRESS + TIM_CCE_OFFSET)
#define TIM2_PRESCALER_ADDRESS					(TIM2_BASE_ADDRESS + TIM_PRS_OFFSET)
#define TIM2_ARR_ADDRESS						(TIM2_BASE_ADDRESS + TIM_ARR_OFFSET)
#define TIM2_CCR1_ADDRESS						(TIM2_BASE_ADDRESS + TIM_CCR1_OFFSET)

int main(void)
{
	InitMCOGPIO();		// A8
	Init_GPIO_PWM(); 	// A0

	SystemClock_Config();

	Start_TIM_PWM();

    /* Loop forever */
	for(;;);
}

/**
 * Function to init GPIO to output the PLL clock on pin A8
 */
void InitMCOGPIO(void){
	// Set Clock Output to PLL
	uint32_t* clock_config_reg = (uint32_t*) RCC_CLOCK_CONFIG_ADDRESS;
	(*clock_config_reg) |= (0x1 << 21);
	(*clock_config_reg) |= (0x1 << 22);

	// Set MCO1 prescaler to 4
	(*clock_config_reg) |= (1 << 26);
	(*clock_config_reg) |= (1 << 25);

	// Enable A8 Pin For MCO output
	uint32_t* AHB1_ce_address = (uint32_t*) RCC_AHB1_CE_ADDRESS;
	// Enable GPIOA clk
	(*AHB1_ce_address) |= (1 << 0);

	// Set GPIO Pin 8 As AF
	uint32_t* gpioa_port_mode_reg = (uint32_t*) GPIOA_Port_Mode_ADDRESS;
	(*gpioa_port_mode_reg) |= (1 << 17);

	// Set AF to AF0 (clear all bits)
	uint32_t* gpioa_af_high_reg = (uint32_t*) GPIOA_AF_HIGH_ADDRESS;
	(*gpioa_af_high_reg) &= ~(0xF << 0);
}

void Init_GPIO_PWM(void){
	// Enable GPIO A Bus Clock
	uint32_t* AHB1_ce_address = (uint32_t*) RCC_AHB1_CE_ADDRESS;
	(*AHB1_ce_address) |= (1 << 0);

	// Set af mode 1
	uint32_t* GPIOA_port_mode_reg = (uint32_t*) GPIOA_Port_Mode_ADDRESS;
	(*GPIOA_port_mode_reg) |= (1 << 1);
	(*GPIOA_port_mode_reg) &= ~(1 << 0);

	uint32_t* GPIOA_af_low_reg = (uint32_t*) GPIOA_AF_LOW_ADDRESS;
	(*GPIOA_af_low_reg) |= (1 << 0);

	// Set push pull
	uint32_t* GPIOA_output_type_reg = (uint32_t*) GPIOA_Output_Type_ADDRESS;
	(*GPIOA_output_type_reg) &= ~(1 << 0);

	// Set speed to high
	uint32_t* GPIOA_output_speed_reg = (uint32_t*) GPIOA_Output_Speed_ADDRESS;
	(*GPIOA_output_speed_reg) |= (0x3 << 0);
}

void Start_TIM_PWM(void){

	// Enable bus clock
	uint32_t* apb1_clk_enable_reg = (uint32_t*) RCC_APB1_CE_ADDRESS;
	(*apb1_clk_enable_reg) |= (1 << 0);

	// Set Prescaler
	uint16_t* tim_prescaler_reg = (uint16_t*) TIM2_PRESCALER_ADDRESS;
	(*tim_prescaler_reg) &= ~(0x0);

	// Start Auto Reload Reg for 50Hz count to 1,000,000 = 0xF4240
	uint32_t* time2_arr_reg = (uint32_t*) TIM2_ARR_ADDRESS;
	(*time2_arr_reg) = 0xF4240;

	// PWM

	// Set PWM Mode 1 in OCxM reg in TIMx_CCMRx
	uint32_t* tim2_compare_capture_mode_reg = (uint32_t*) TIM2_COMPARE_CAPTURE_MODE_1_ADDRESS;
	(*tim2_compare_capture_mode_reg) |= (0x3 << 5);
	(*tim2_compare_capture_mode_reg) &= ~(1 << 4);

	// Enable preload on compare reg
	(*tim2_compare_capture_mode_reg) |= (1 << 3);

	// Enable auto reload preload buffer
	uint32_t* tim2_control_reg_1 = (uint32_t*) TIM2_CONTROL_ADDRESS;
	(*tim2_control_reg_1) |= (1 << 7);

	// Set Compare Capture Value
	uint32_t* tim2_compare_capture_value_ch1 = (uint32_t*) TIM2_CCR1_ADDRESS;
	(*tim2_compare_capture_value_ch1) = 0x3D090;

	// Compare Capture Output Enable
	uint32_t* tim2_cap_comp_enable_reg = (uint32_t*) TIM2_CAP_COMP_ENABLE_ADDRESS;
	(*tim2_cap_comp_enable_reg) |= (1 << 0);

	// Enable UG bit in TIMx_EGR
	uint32_t* tim2_egr_reg = (uint32_t*) TIM2_EGR_ADDRESS;
	(*tim2_egr_reg) |= (1 << 0);

	// Enable TIM
	(*tim2_control_reg_1) |= (1 << 0);
}

/**
 * Function to configure system clock to set flash status and update
 * clock to be PLL with HSE and update pre-scalers
 */
void SystemClock_Config(void){

	// Update Flash Wait States To Appropriate Value For Intended Clock Speed
	uint32_t* flash_access_control_reg = (uint32_t*) FLASH_ACCESS_CONTROL_ADDRESS;

	// Enable prefetch buffer (prefetch buffer must be disabled when the **supply** voltage is below 2.1 V)
	(*flash_access_control_reg) |= (1 << 8);

	// Update Latency to one wait state
	(*flash_access_control_reg) |= (1 << 0);

	// Enable clock for PWR at bit pos 28 if clk is over 84Mhz update VOS
	// uint32_t* apb1_clock_enable_address = RCC_APB1_CE_ADDRESS;
	// (*apb1_clock_enable_address) |= (1 << 28);

	// Update VOS to Scale Mode 1 <= 100MHz
	// uint32_t* pwr_control_register = PWR_CR_ADDRESS;
	// (*pwr_control_register) |= (1 << 15);
	// (*pwr_control_register) |= (1 << 14);

	// Enable HSE
	uint32_t* clock_control_register = (uint32_t*) RCC_CLOCK_CONTROL_ADDRESS;
	(*clock_control_register) |= (1 << 16);

	// Wait for clock ready flag
	while(!( (*clock_control_register) & (1 << 17) ));

	// Make sure PLL is disabled
	(*clock_control_register) &= ~(1 << 24);

	// Config PLL Output = (HSE / PLLM) * (PLLN / PLLP)
	uint32_t* pll_config_register = (uint32_t*) RCC_PLL_ADDRESS;

	// Make input HSE
	(*pll_config_register) |= (0x1 << 22);

	// PLLM must be between 1 & 2 MHz - HSE input is 25MHz (0x19 = 25)
	(*pll_config_register) &= ~(0x1F << 0);
	(*pll_config_register) |= (0x19 << 0);

	// Config PLLN - Between 50 - 432 inclusive (0x64 = 100)
	(*pll_config_register) &= ~(0x1FF << 6);
	(*pll_config_register) |= (0x64 << 6);

	// Config PLLP - 2 or 4 or 6 or 8 (00 = 2)
	(*pll_config_register) &= ~(0x1 << 17);
	(*pll_config_register) &= ~(0x1 << 16);

	// Turn PLL on
	(*clock_control_register) |= (1 << 24);

	// Wait for PLL ready flag
	while(!( (*clock_control_register) & (1 << 25) ));

	// Set System Clock To PLL
	uint32_t* clock_config_register = (uint32_t*) RCC_CLOCK_CONFIG_ADDRESS;
	(*clock_config_register) |= (1 << 1);
	(*clock_config_register) &= ~(1 << 0);

	// Wait for clock to be set to pll
	while(!((*clock_config_register) & (1 << 3)) && (*clock_config_register) & (1 << 2));

	// Set AHB Clock Prescaler to not divide (MAX 100MHz)
	(*clock_config_register) &= ~(1 << 7);

	// Set APB1 Prescaler to not divide (MAX 50MHz)
	(*clock_config_register) &= ~(1 << 12);

	// Set APB2 Prescaler to not divide (MAX 100MHz)
	(*clock_config_register) &= ~(1 << 15);
}
