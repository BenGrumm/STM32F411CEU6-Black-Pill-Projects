/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

void Init_ADC_Single(void);
void Init_ADC_GPIO(void);

#define NVIC_ISE_REG 							(0xE000E100UL)

#define FLASH_BASE_ADDRESS						(0x40023C00UL)
#define RCC_BASE_ADDRESS 						(0x40023800UL)
#define ADC_BASE_ADDERSS						(0x40012000UL)
#define GPIOA_BASE_ADDRESS						(0x40020000UL)

#define RCC_CLOCK_CONTROL_OFFSET				(0x00UL)
#define RCC_PLL_CLOCK_CONFIG_OFFSET				(0x04UL)
#define RCC_CLOCK_CONFIG_OFFSET					(0x08UL)
#define RCC_AHB1_CE_OFFSET 						(0x30UL)
#define RCC_APB1_CE_OFFSET 						(0x40UL)
#define RCC_APB2_CE_OFFSET						(0x44UL)

#define GPIO_Port_Mode_Offset					(0x00UL)
#define GPIO_Output_Type_Offset					(0x04UL) // Type
#define GPIO_Output_Speed_Offset				(0x08UL) // Speed
#define GPIO_PUPD_Offset						(0x0CUL) // Pull Up / Pull Down
#define GPIO_BSR_Offset							(0x18UL) // Bit Set / Reset
#define GPIO_AF_LOW_Offset						(0x20UL)
#define GPIO_AF_HIGH_Offset						(0x24UL)

#define ADC_SR_OFFSET							(0x00UL)
#define ADC_CR1_OFFSET							(0x04UL)
#define ADC_CR2_OFFSET							(0x08UL)
#define ADC_SMPR2_OFFSET						(0x10UL)
#define ADC_SQR1_OFFSET							(0x2CUL)
#define ADC_SQR3_OFFSET							(0x34UL)
#define ADC_DR_OFFSET							(0x4CUL)
#define ADC_CCR_OFFSET							(0x04UL) // (this offset address is relative to ADC1 base address + 0x300)

#define RCC_CLOCK_CONTROL_ADDRESS				(RCC_BASE_ADDRESS + RCC_CLOCK_CONTROL_OFFSET)
#define RCC_PLL_ADDRESS							(RCC_BASE_ADDRESS + RCC_PLL_CLOCK_CONFIG_OFFSET)
#define RCC_CLOCK_CONFIG_ADDRESS				(RCC_BASE_ADDRESS + RCC_CLOCK_CONFIG_OFFSET)
#define RCC_AHB1_CE_ADDRESS						(RCC_BASE_ADDRESS + RCC_AHB1_CE_OFFSET)
#define RCC_APB1_CE_ADDRESS 					(RCC_BASE_ADDRESS + RCC_APB1_CE_OFFSET)
#define RCC_APB2_CE_ADDRESS 					(RCC_BASE_ADDRESS + RCC_APB2_CE_OFFSET)

#define GPIOA_Port_Mode_ADDRESS 				(GPIOA_BASE_ADDRESS + GPIO_Port_Mode_Offset)
#define GPIOA_Output_Type_ADDRESS 				(GPIOA_BASE_ADDRESS + GPIO_Output_Type_Offset)
#define GPIOA_Output_Speed_ADDRESS 				(GPIOA_BASE_ADDRESS + GPIO_Output_Speed_Offset)
#define GPIOA_PUPD_ADDRESS 						(GPIOA_BASE_ADDRESS + GPIO_PUPD_Offset)
#define GPIOA_BSR_ADDRESS 						(GPIOA_BASE_ADDRESS + GPIO_BSR_Offset)
#define GPIOA_AF_LOW_ADDRESS					(GPIOA_BASE_ADDRESS + GPIO_AF_LOW_Offset)
#define GPIOA_AF_HIGH_ADDRESS					(GPIOA_BASE_ADDRESS + GPIO_AF_HIGH_Offset)

#define ADC_SR									(ADC_BASE_ADDERSS + ADC_SR_OFFSET)
#define ADC_CR1									(ADC_BASE_ADDERSS + ADC_CR1_OFFSET)
#define ADC_CR2									(ADC_BASE_ADDERSS + ADC_CR2_OFFSET)
#define ADC_SMPR2								(ADC_BASE_ADDERSS + ADC_SMPR2_OFFSET)
#define ADC_SQR1								(ADC_BASE_ADDERSS + ADC_SQR1_OFFSET)
#define ADC_SQR3								(ADC_BASE_ADDERSS + ADC_SQR3_OFFSET)
#define ADC_DR									(ADC_BASE_ADDERSS + ADC_DR_OFFSET)
#define ADC_CCR									(ADC_BASE_ADDERSS + ADC_CCR_OFFSET)

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

volatile uint32_t ADCVal = 0;

int main(void)
{
	printf("Initing\n");

	Init_ADC_GPIO();

	Init_ADC_Single();

	printf("Inited\n");

    /* Loop forever */
	for(;;){
		printf("%lu\n", ADCVal);

		for(int i = 0; i < 2000; i++){
			i++;
		}
	}
}

void Init_ADC_GPIO(void){
	// Setup ADC input as Analogue On ADC1_4 (PA4)
	uint32_t *AHB1_Bus = (uint32_t*) RCC_AHB1_CE_ADDRESS;
	(*AHB1_Bus) |= (1 << 0);

	uint32_t *GPIOA_Mode_Reg = (uint32_t*) GPIOA_Port_Mode_ADDRESS;
	(*GPIOA_Mode_Reg) |= (0x3 << 8);

}

void Init_ADC_Single(void){

	// Enable RCC ADC Clock
	uint32_t *RCC_APB2_CE_Reg = (uint32_t*) RCC_APB2_CE_ADDRESS;
	(*RCC_APB2_CE_Reg) |= (1 << 8);

	// Change ADC Pre-scaler So Clock Doesn't Exceed 36 MHz when Vdda > 2.4v (in data sheet under 12-bit ADC characteristics 6.3.20)
	uint32_t *ADC_CC_Reg = (uint32_t*) ADC_CCR;
	// Default 00 = / 2

	// Set number of channels to sample (default 1 so if sampling 1 dont change) ADC_SQR1
	uint32_t *ADC_SQ1_Reg = (uint32_t*) ADC_SQR1;

	// Set Channel To Convert In Sequence Reg 0 (channel 4)
	uint32_t *ADC_SQ3_Reg = (uint32_t*) ADC_SQR3;
	(*ADC_SQ3_Reg) |= (0x4 << 0);

	// Enable end of conversion interrupt
	uint32_t *ADC_CR1_Reg = (uint32_t*) ADC_CR1;
	(*ADC_CR1_Reg) |= (1 << 5);

	// Enable NVIC IRQ For ADC (channel 18)
	uint32_t *NVIC_Interrupt_Enable_Reg = (uint32_t*) NVIC_ISE_REG;
	(*NVIC_Interrupt_Enable_Reg) |= (1 << 18);

	// Set sampling rate
	uint32_t *ADC_SMP_Time_2_Reg = (uint32_t*) ADC_SMPR2;
	(*ADC_SMP_Time_2_Reg) |= (0x7 << 12);

	// Enable & set to continuous
	uint32_t *ADC_CR2_Reg = (uint32_t*) ADC_CR2;
	(*ADC_CR2_Reg) |= (1 << 1);
	(*ADC_CR2_Reg) |= (1 << 0);

	// Wait for Tstab time to stabilise from power down
	// TODO
	for(int i = 0; i < 2000; i++){
		i++;
	}

	// Enable for 2nd time
	(*ADC_CR2_Reg) |= (1 << 0);

	// Run calibration // Wait for calibration to be complete = 0 ????

	// Run SWSTART to start conversion
	(*ADC_CR2_Reg) |= (1 << 30);
}

// Add IRQ Handler to check stuff
void ADC_IRQHandler(void){
	// If end of conversion flag is set
	uint32_t *ADC_SR_Reg = (uint32_t*) ADC_SR;
	volatile uint32_t *ADC_DR_Reg = (uint32_t*) ADC_DR;

	// The EOC bit is clear by reading the ADC_DR
	if((*ADC_SR_Reg) & (1 << 1)){
		// Assign Value From DR
		ADCVal = (*ADC_DR_Reg);
	}
}
